/**
 * @file esp_idf_spi_demo.cpp
 * @brief ESP-IDF SPI API demonstration for M5Stack Tab5 Emulator
 * 
 * This example demonstrates how to use the ESP-IDF SPI master API
 * to communicate with SPI devices on the M5Stack Tab5 platform.
 * 
 * M5Stack Tab5 SPI Usage:
 * - SPI2: Display controller (MIPI-DSI), Touch panel (GT911)
 * - SPI3: SD Card interface, External sensor bus
 */

#include <iostream>
#include <vector>
#include <thread>
#include <chrono>
#include <iomanip>

extern "C" {
    #include "emulator/esp_idf/esp_idf.h"
    #include "emulator/esp_idf/driver/spi_master.h"
}

#include "emulator/core/emulator_core.hpp"
#include "emulator/config/configuration.hpp"

/**
 * @brief M5Stack Tab5 SPI Pin Definitions
 */
namespace m5tab5_pins {
    // SPI2 pins (Display/Touch)
    constexpr int SPI2_MOSI = 11;
    constexpr int SPI2_MISO = 13; 
    constexpr int SPI2_SCLK = 12;
    constexpr int SPI2_CS_DISPLAY = 10;
    constexpr int SPI2_CS_TOUCH = 21;
    
    // SPI3 pins (SD Card/External)
    constexpr int SPI3_MOSI = 35;
    constexpr int SPI3_MISO = 37;
    constexpr int SPI3_SCLK = 36;
    constexpr int SPI3_CS_SD = 34;
    constexpr int SPI3_CS_EXT = 33;
}

/**
 * @brief Simulate display controller initialization sequence
 */
void demo_display_controller() {
    std::cout << "\n=== M5Stack Tab5 Display Controller Demo ===\n";
    
    // Configure SPI bus for display
    spi_bus_config_t bus_config = {};
    bus_config.mosi_io_num = m5tab5_pins::SPI2_MOSI;
    bus_config.miso_io_num = m5tab5_pins::SPI2_MISO;
    bus_config.sclk_io_num = m5tab5_pins::SPI2_SCLK;
    bus_config.quadwp_io_num = -1;
    bus_config.quadhd_io_num = -1;
    bus_config.max_transfer_sz = 4096;
    bus_config.flags = SPICOMMON_BUSFLAG_MASTER;
    
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &bus_config, 1);
    if (ret != ESP_OK) {
        std::cerr << "Failed to initialize SPI bus: " << esp_err_to_name(ret) << std::endl;
        return;
    }
    std::cout << "SPI2 bus initialized for display communication\n";
    
    // Configure display device
    spi_device_interface_config_t dev_config = {};
    dev_config.mode = 0;  // SPI mode 0\n    dev_config.clock_speed_hz = 40000000;  // 40 MHz\n    dev_config.spics_io_num = m5tab5_pins::SPI2_CS_DISPLAY;\n    dev_config.queue_size = 7;\n    dev_config.command_bits = 8;\n    dev_config.address_bits = 0;\n    dev_config.dummy_bits = 0;\n    \n    spi_device_handle_t display_handle;\n    ret = spi_bus_add_device(SPI2_HOST, &dev_config, &display_handle);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to add display device: \" << esp_err_to_name(ret) << std::endl;\n        spi_bus_free(SPI2_HOST);\n        return;\n    }\n    std::cout << \"Display device added to SPI2 bus\\n\";\n    \n    // Simulate display initialization commands\n    std::vector<uint8_t> init_commands = {\n        0x01,  // Software reset\n        0x11,  // Sleep out\n        0x29,  // Display on\n        0x36,  // Memory access control\n        0x3A,  // Pixel format set\n        0x21,  // Display inversion on\n        0x13   // Normal display mode\n    };\n    \n    std::cout << \"Sending display initialization sequence...\\n\";\n    for (uint8_t cmd : init_commands) {\n        spi_transaction_t trans = {};\n        trans.flags = SPI_TRANS_USE_TXDATA;\n        trans.cmd = cmd;\n        trans.length = 0;  // Command only\n        \n        ret = spi_device_transmit(display_handle, &trans);\n        if (ret == ESP_OK) {\n            std::cout << \"  Command 0x\" << std::hex << (int)cmd << \" sent successfully\\n\";\n        } else {\n            std::cout << \"  Command 0x\" << std::hex << (int)cmd << \" failed: \" \n                      << esp_err_to_name(ret) << \"\\n\";\n        }\n    }\n    \n    // Simulate writing pixel data\n    std::cout << \"Writing test pixel data...\\n\";\n    uint16_t test_pixels[100];  // 100 pixels of test data\n    for (int i = 0; i < 100; i++) {\n        test_pixels[i] = 0xF800;  // Red color (RGB565)\n    }\n    \n    spi_transaction_t pixel_trans = {};\n    pixel_trans.cmd = 0x2C;  // Memory write command\n    pixel_trans.length = 100 * 16;  // 100 pixels * 16 bits each\n    pixel_trans.tx_buffer = test_pixels;\n    \n    ret = spi_device_transmit(display_handle, &pixel_trans);\n    if (ret == ESP_OK) {\n        std::cout << \"  Pixel data written successfully (100 red pixels)\\n\";\n    } else {\n        std::cout << \"  Pixel data write failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Cleanup\n    spi_bus_remove_device(display_handle);\n    spi_bus_free(SPI2_HOST);\n    std::cout << \"Display demo completed\\n\";\n}\n\n/**\n * @brief Simulate touch panel communication\n */\nvoid demo_touch_controller() {\n    std::cout << \"\\n=== M5Stack Tab5 Touch Controller Demo ===\\n\";\n    \n    // Configure SPI bus for touch (reuse SPI2 with different device)\n    spi_bus_config_t bus_config = {};\n    bus_config.mosi_io_num = m5tab5_pins::SPI2_MOSI;\n    bus_config.miso_io_num = m5tab5_pins::SPI2_MISO;\n    bus_config.sclk_io_num = m5tab5_pins::SPI2_SCLK;\n    bus_config.quadwp_io_num = -1;\n    bus_config.quadhd_io_num = -1;\n    bus_config.max_transfer_sz = 1024;\n    bus_config.flags = SPICOMMON_BUSFLAG_MASTER;\n    \n    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &bus_config, 1);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to initialize SPI bus: \" << esp_err_to_name(ret) << std::endl;\n        return;\n    }\n    \n    // Configure GT911 touch controller device\n    spi_device_interface_config_t touch_config = {};\n    touch_config.mode = 0;  // SPI mode 0\n    touch_config.clock_speed_hz = 10000000;  // 10 MHz\n    touch_config.spics_io_num = m5tab5_pins::SPI2_CS_TOUCH;\n    touch_config.queue_size = 3;\n    touch_config.command_bits = 0;\n    touch_config.address_bits = 16;  // GT911 uses 16-bit addresses\n    touch_config.dummy_bits = 0;\n    \n    spi_device_handle_t touch_handle;\n    ret = spi_bus_add_device(SPI2_HOST, &touch_config, &touch_handle);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to add touch device: \" << esp_err_to_name(ret) << std::endl;\n        spi_bus_free(SPI2_HOST);\n        return;\n    }\n    std::cout << \"GT911 touch controller added to SPI2 bus\\n\";\n    \n    // Read touch controller ID\n    std::cout << \"Reading touch controller product ID...\\n\";\n    spi_transaction_t read_id_trans = {};\n    read_id_trans.flags = SPI_TRANS_USE_ADDR | SPI_TRANS_USE_RXDATA;\n    read_id_trans.addr = 0x8140;  // GT911 Product ID register\n    read_id_trans.length = 32;    // 4 bytes\n    \n    ret = spi_device_transmit(touch_handle, &read_id_trans);\n    if (ret == ESP_OK) {\n        std::cout << \"  Touch controller ID: \";\n        for (int i = 0; i < 4; i++) {\n            std::cout << std::hex << (int)read_id_trans.rx_data[i] << \" \";\n        }\n        std::cout << \"\\n\";\n    } else {\n        std::cout << \"  Failed to read touch controller ID: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Simulate touch data reading\n    std::cout << \"Reading touch point data...\\n\";\n    uint8_t touch_data[40];  // Buffer for touch point data\n    \n    spi_transaction_t touch_read_trans = {};\n    touch_read_trans.flags = SPI_TRANS_USE_ADDR;\n    touch_read_trans.addr = 0x814E;  // GT911 touch data register\n    touch_read_trans.length = 40 * 8;  // 40 bytes\n    touch_read_trans.rx_buffer = touch_data;\n    \n    ret = spi_device_transmit(touch_handle, &touch_read_trans);\n    if (ret == ESP_OK) {\n        std::cout << \"  Touch data read successfully (\" << sizeof(touch_data) << \" bytes)\\n\";\n        std::cout << \"  Simulated touch points: \";\n        // Simulate 2 touch points\n        std::cout << \"Point1(120, 200) Point2(300, 400)\\n\";\n    } else {\n        std::cout << \"  Failed to read touch data: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Cleanup\n    spi_bus_remove_device(touch_handle);\n    spi_bus_free(SPI2_HOST);\n    std::cout << \"Touch controller demo completed\\n\";\n}\n\n/**\n * @brief Simulate SD card communication\n */\nvoid demo_sd_card() {\n    std::cout << \"\\n=== M5Stack Tab5 SD Card Demo ===\\n\";\n    \n    // Configure SPI bus for SD card\n    spi_bus_config_t bus_config = {};\n    bus_config.mosi_io_num = m5tab5_pins::SPI3_MOSI;\n    bus_config.miso_io_num = m5tab5_pins::SPI3_MISO;\n    bus_config.sclk_io_num = m5tab5_pins::SPI3_SCLK;\n    bus_config.quadwp_io_num = -1;\n    bus_config.quadhd_io_num = -1;\n    bus_config.max_transfer_sz = 512;  // SD block size\n    bus_config.flags = SPICOMMON_BUSFLAG_MASTER;\n    \n    esp_err_t ret = spi_bus_initialize(SPI3_HOST, &bus_config, 2);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to initialize SPI bus: \" << esp_err_to_name(ret) << std::endl;\n        return;\n    }\n    \n    // Configure SD card device (SPI mode)\n    spi_device_interface_config_t sd_config = {};\n    sd_config.mode = 0;  // SPI mode 0\n    sd_config.clock_speed_hz = 400000;  // Start with 400kHz for initialization\n    sd_config.spics_io_num = m5tab5_pins::SPI3_CS_SD;\n    sd_config.queue_size = 5;\n    sd_config.command_bits = 0;\n    sd_config.address_bits = 0;\n    sd_config.dummy_bits = 0;\n    sd_config.flags = SPI_DEVICE_HALFDUPLEX;  // SD card is half-duplex\n    \n    spi_device_handle_t sd_handle;\n    ret = spi_bus_add_device(SPI3_HOST, &sd_config, &sd_handle);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to add SD card device: \" << esp_err_to_name(ret) << std::endl;\n        spi_bus_free(SPI3_HOST);\n        return;\n    }\n    std::cout << \"SD card device added to SPI3 bus\\n\";\n    \n    // SD card initialization sequence\n    std::cout << \"Sending SD card initialization commands...\\n\";\n    \n    // CMD0: GO_IDLE_STATE\n    spi_transaction_t cmd0 = {};\n    cmd0.flags = SPI_TRANS_USE_TXDATA;\n    cmd0.length = 48;  // SD command is 6 bytes\n    cmd0.tx_data[0] = 0x40;  // CMD0\n    cmd0.tx_data[1] = 0x00;  // Argument\n    cmd0.tx_data[2] = 0x00;\n    cmd0.tx_data[3] = 0x00;\n    cmd0.tx_data[4] = 0x00;\n    cmd0.tx_data[5] = 0x95;  // CRC\n    \n    ret = spi_device_transmit(sd_handle, &cmd0);\n    if (ret == ESP_OK) {\n        std::cout << \"  CMD0 (GO_IDLE_STATE) sent successfully\\n\";\n    } else {\n        std::cout << \"  CMD0 failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // CMD8: SEND_IF_COND\n    spi_transaction_t cmd8 = {};\n    cmd8.flags = SPI_TRANS_USE_TXDATA | SPI_TRANS_USE_RXDATA;\n    cmd8.length = 48;  // 6 bytes command\n    cmd8.rxlength = 40;  // 5 bytes response\n    cmd8.tx_data[0] = 0x48;  // CMD8\n    cmd8.tx_data[1] = 0x00;  // Argument: VHS=1, check pattern=0xAA\n    cmd8.tx_data[2] = 0x00;\n    cmd8.tx_data[3] = 0x01;\n    cmd8.tx_data[4] = 0xAA;\n    cmd8.tx_data[5] = 0x87;  // CRC\n    \n    ret = spi_device_transmit(sd_handle, &cmd8);\n    if (ret == ESP_OK) {\n        std::cout << \"  CMD8 (SEND_IF_COND) sent successfully\\n\";\n        std::cout << \"  Response: \";\n        for (int i = 0; i < 4; i++) {\n            std::cout << std::hex << (int)cmd8.rx_data[i] << \" \";\n        }\n        std::cout << \"\\n\";\n    } else {\n        std::cout << \"  CMD8 failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Simulate block read (CMD17)\n    std::cout << \"Reading SD card block 0...\\n\";\n    uint8_t block_data[512];  // One block\n    \n    spi_transaction_t cmd17 = {};\n    cmd17.flags = SPI_TRANS_USE_TXDATA;\n    cmd17.length = 48;  // 6 bytes command\n    cmd17.tx_data[0] = 0x51;  // CMD17\n    cmd17.tx_data[1] = 0x00;  // Block address 0\n    cmd17.tx_data[2] = 0x00;\n    cmd17.tx_data[3] = 0x00;\n    cmd17.tx_data[4] = 0x00;\n    cmd17.tx_data[5] = 0xFF;  // Dummy CRC\n    \n    ret = spi_device_transmit(sd_handle, &cmd17);\n    if (ret == ESP_OK) {\n        std::cout << \"  CMD17 (READ_SINGLE_BLOCK) sent successfully\\n\";\n        \n        // Read block data (normally would wait for data token first)\n        spi_transaction_t read_block = {};\n        read_block.length = 512 * 8;  // 512 bytes\n        read_block.rx_buffer = block_data;\n        \n        ret = spi_device_transmit(sd_handle, &read_block);\n        if (ret == ESP_OK) {\n            std::cout << \"  Block data read successfully (512 bytes)\\n\";\n            std::cout << \"  First 16 bytes: \";\n            for (int i = 0; i < 16; i++) {\n                std::cout << std::hex << (int)block_data[i] << \" \";\n            }\n            std::cout << \"\\n\";\n        } else {\n            std::cout << \"  Block read failed: \" << esp_err_to_name(ret) << \"\\n\";\n        }\n    } else {\n        std::cout << \"  CMD17 failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Cleanup\n    spi_bus_remove_device(sd_handle);\n    spi_bus_free(SPI3_HOST);\n    std::cout << \"SD card demo completed\\n\";\n}\n\n/**\n * @brief Demonstrate SPI frequency and timing calculations\n */\nvoid demo_spi_timing() {\n    std::cout << \"\\n=== SPI Timing and Frequency Demo ===\\n\";\n    \n    const int apb_freq = 80000000;  // 80 MHz APB clock\n    \n    // Test different target frequencies\n    std::vector<int> target_frequencies = {100000, 1000000, 10000000, 25000000, 40000000};\n    \n    std::cout << \"Frequency calculations for different targets:\\n\";\n    for (int target_freq : target_frequencies) {\n        int actual_freq = spi_get_actual_clock(apb_freq, target_freq, 128);\n        double accuracy = (double)actual_freq / target_freq * 100.0;\n        \n        std::cout << \"  Target: \" << target_freq / 1000 << \" kHz, \";\n        std::cout << \"Actual: \" << actual_freq / 1000 << \" kHz \";\n        std::cout << \"(\" << std::fixed << std::setprecision(1) << accuracy << \"%)\\n\";\n    }\n    \n    // Test timing calculations\n    std::cout << \"\\nTiming calculations:\\n\";\n    int dummy_bits, cycles_remain;\n    \n    esp_err_t ret = spi_get_timing(false, 0, 40000000, &dummy_bits, &cycles_remain);\n    if (ret == ESP_OK) {\n        std::cout << \"  40 MHz: dummy_bits=\" << dummy_bits \n                  << \", cycles_remain=\" << cycles_remain << \"\\n\";\n    }\n    \n    ret = spi_get_timing(true, 10, 10000000, &dummy_bits, &cycles_remain);\n    if (ret == ESP_OK) {\n        std::cout << \"  10 MHz (GPIO): dummy_bits=\" << dummy_bits \n                  << \", cycles_remain=\" << cycles_remain << \"\\n\";\n    }\n    \n    // Get frequency limits\n    int limit_iomux = spi_get_freq_limit(false, 0);\n    int limit_gpio = spi_get_freq_limit(true, 10);\n    \n    std::cout << \"\\nFrequency limits:\\n\";\n    std::cout << \"  IOMUX pins: \" << limit_iomux / 1000000 << \" MHz\\n\";\n    std::cout << \"  GPIO matrix: \" << limit_gpio / 1000000 << \" MHz\\n\";\n}\n\nint main() {\n    std::cout << \"M5Stack Tab5 ESP-IDF SPI API Demonstration\\n\";\n    std::cout << \"==========================================\\n\";\n    \n    try {\n        // Create and initialize emulator\n        auto config_result = m5tab5::emulator::config::Configuration::load_default();\n        if (!config_result.has_value()) {\n            std::cerr << \"Failed to load emulator configuration\" << std::endl;\n            return 1;\n        }\n        \n        auto emulator_result = m5tab5::emulator::EmulatorCore::create(config_result.value());\n        if (!emulator_result.has_value()) {\n            std::cerr << \"Failed to create emulator core\" << std::endl;\n            return 1;\n        }\n        \n        auto emulator = std::move(emulator_result.value());\n        auto init_result = emulator->initialize();\n        if (!init_result.has_value()) {\n            std::cerr << \"Failed to initialize emulator\" << std::endl;\n            return 1;\n        }\n        \n        // Initialize ESP-IDF layer\n        esp_err_t esp_result = esp_idf_init_all_with_core(emulator.get());\n        if (esp_result != ESP_OK) {\n            std::cerr << \"Failed to initialize ESP-IDF layer: \" \n                      << esp_err_to_name(esp_result) << std::endl;\n            return 1;\n        }\n        \n        std::cout << \"Emulator initialized successfully\\n\";\n        std::cout << \"ESP-IDF emulation version: \" << esp_idf_get_emulation_version() << \"\\n\\n\";\n        \n        // Run SPI demonstrations\n        demo_display_controller();\n        demo_touch_controller();\n        demo_sd_card();\n        demo_spi_timing();\n        \n        std::cout << \"\\n=== Demo Summary ===\\n\";\n        std::cout << \"✓ Display controller SPI communication demonstrated\\n\";\n        std::cout << \"✓ Touch panel SPI communication demonstrated\\n\";\n        std::cout << \"✓ SD card SPI communication demonstrated\\n\";\n        std::cout << \"✓ SPI timing and frequency calculations demonstrated\\n\";\n        std::cout << \"\\nAll M5Stack Tab5 SPI features working correctly!\\n\";\n        \n        // Cleanup\n        esp_idf_deinit_all();\n        emulator->shutdown();\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Exception occurred: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}"
    \""
}
    \n    // Configure display device\n    spi_device_interface_config_t dev_config = {};\n    dev_config.mode = 0;  // SPI mode 0\n    dev_config.clock_speed_hz = 40000000;  // 40 MHz\n    dev_config.spics_io_num = m5tab5_pins::SPI2_CS_DISPLAY;\n    dev_config.queue_size = 7;\n    dev_config.command_bits = 8;\n    dev_config.address_bits = 0;\n    dev_config.dummy_bits = 0;\n    \n    spi_device_handle_t display_handle;\n    ret = spi_bus_add_device(SPI2_HOST, &dev_config, &display_handle);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to add display device: \" << esp_err_to_name(ret) << std::endl;\n        spi_bus_free(SPI2_HOST);\n        return;\n    }\n    std::cout << \"Display device added to SPI2 bus\\n\";\n    \n    // Simulate display initialization commands\n    std::vector<uint8_t> init_commands = {\n        0x01,  // Software reset\n        0x11,  // Sleep out\n        0x29,  // Display on\n        0x36,  // Memory access control\n        0x3A,  // Pixel format set\n        0x21,  // Display inversion on\n        0x13   // Normal display mode\n    };\n    \n    std::cout << \"Sending display initialization sequence...\\n\";\n    for (uint8_t cmd : init_commands) {\n        spi_transaction_t trans = {};\n        trans.flags = SPI_TRANS_USE_TXDATA;\n        trans.cmd = cmd;\n        trans.length = 0;  // Command only\n        \n        ret = spi_device_transmit(display_handle, &trans);\n        if (ret == ESP_OK) {\n            std::cout << \"  Command 0x\" << std::hex << (int)cmd << \" sent successfully\\n\";\n        } else {\n            std::cout << \"  Command 0x\" << std::hex << (int)cmd << \" failed: \" \n                      << esp_err_to_name(ret) << \"\\n\";\n        }\n    }\n    \n    // Simulate writing pixel data\n    std::cout << \"Writing test pixel data...\\n\";\n    uint16_t test_pixels[100];  // 100 pixels of test data\n    for (int i = 0; i < 100; i++) {\n        test_pixels[i] = 0xF800;  // Red color (RGB565)\n    }\n    \n    spi_transaction_t pixel_trans = {};\n    pixel_trans.cmd = 0x2C;  // Memory write command\n    pixel_trans.length = 100 * 16;  // 100 pixels * 16 bits each\n    pixel_trans.tx_buffer = test_pixels;\n    \n    ret = spi_device_transmit(display_handle, &pixel_trans);\n    if (ret == ESP_OK) {\n        std::cout << \"  Pixel data written successfully (100 red pixels)\\n\";\n    } else {\n        std::cout << \"  Pixel data write failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Cleanup\n    spi_bus_remove_device(display_handle);\n    spi_bus_free(SPI2_HOST);\n    std::cout << \"Display demo completed\\n\";\n}\n\n/**\n * @brief Simulate touch panel communication\n */\nvoid demo_touch_controller() {\n    std::cout << \"\\n=== M5Stack Tab5 Touch Controller Demo ===\\n\";\n    \n    // Configure SPI bus for touch (reuse SPI2 with different device)\n    spi_bus_config_t bus_config = {};\n    bus_config.mosi_io_num = m5tab5_pins::SPI2_MOSI;\n    bus_config.miso_io_num = m5tab5_pins::SPI2_MISO;\n    bus_config.sclk_io_num = m5tab5_pins::SPI2_SCLK;\n    bus_config.quadwp_io_num = -1;\n    bus_config.quadhd_io_num = -1;\n    bus_config.max_transfer_sz = 1024;\n    bus_config.flags = SPICOMMON_BUSFLAG_MASTER;\n    \n    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &bus_config, 1);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to initialize SPI bus: \" << esp_err_to_name(ret) << std::endl;\n        return;\n    }\n    \n    // Configure GT911 touch controller device\n    spi_device_interface_config_t touch_config = {};\n    touch_config.mode = 0;  // SPI mode 0\n    touch_config.clock_speed_hz = 10000000;  // 10 MHz\n    touch_config.spics_io_num = m5tab5_pins::SPI2_CS_TOUCH;\n    touch_config.queue_size = 3;\n    touch_config.command_bits = 0;\n    touch_config.address_bits = 16;  // GT911 uses 16-bit addresses\n    touch_config.dummy_bits = 0;\n    \n    spi_device_handle_t touch_handle;\n    ret = spi_bus_add_device(SPI2_HOST, &touch_config, &touch_handle);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to add touch device: \" << esp_err_to_name(ret) << std::endl;\n        spi_bus_free(SPI2_HOST);\n        return;\n    }\n    std::cout << \"GT911 touch controller added to SPI2 bus\\n\";\n    \n    // Read touch controller ID\n    std::cout << \"Reading touch controller product ID...\\n\";\n    spi_transaction_t read_id_trans = {};\n    read_id_trans.flags = SPI_TRANS_USE_ADDR | SPI_TRANS_USE_RXDATA;\n    read_id_trans.addr = 0x8140;  // GT911 Product ID register\n    read_id_trans.length = 32;    // 4 bytes\n    \n    ret = spi_device_transmit(touch_handle, &read_id_trans);\n    if (ret == ESP_OK) {\n        std::cout << \"  Touch controller ID: \";\n        for (int i = 0; i < 4; i++) {\n            std::cout << std::hex << (int)read_id_trans.rx_data[i] << \" \";\n        }\n        std::cout << \"\\n\";\n    } else {\n        std::cout << \"  Failed to read touch controller ID: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Simulate touch data reading\n    std::cout << \"Reading touch point data...\\n\";\n    uint8_t touch_data[40];  // Buffer for touch point data\n    \n    spi_transaction_t touch_read_trans = {};\n    touch_read_trans.flags = SPI_TRANS_USE_ADDR;\n    touch_read_trans.addr = 0x814E;  // GT911 touch data register\n    touch_read_trans.length = 40 * 8;  // 40 bytes\n    touch_read_trans.rx_buffer = touch_data;\n    \n    ret = spi_device_transmit(touch_handle, &touch_read_trans);\n    if (ret == ESP_OK) {\n        std::cout << \"  Touch data read successfully (\" << sizeof(touch_data) << \" bytes)\\n\";\n        std::cout << \"  Simulated touch points: \";\n        // Simulate 2 touch points\n        std::cout << \"Point1(120, 200) Point2(300, 400)\\n\";\n    } else {\n        std::cout << \"  Failed to read touch data: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Cleanup\n    spi_bus_remove_device(touch_handle);\n    spi_bus_free(SPI2_HOST);\n    std::cout << \"Touch controller demo completed\\n\";\n}\n\n/**\n * @brief Simulate SD card communication\n */\nvoid demo_sd_card() {\n    std::cout << \"\\n=== M5Stack Tab5 SD Card Demo ===\\n\";\n    \n    // Configure SPI bus for SD card\n    spi_bus_config_t bus_config = {};\n    bus_config.mosi_io_num = m5tab5_pins::SPI3_MOSI;\n    bus_config.miso_io_num = m5tab5_pins::SPI3_MISO;\n    bus_config.sclk_io_num = m5tab5_pins::SPI3_SCLK;\n    bus_config.quadwp_io_num = -1;\n    bus_config.quadhd_io_num = -1;\n    bus_config.max_transfer_sz = 512;  // SD block size\n    bus_config.flags = SPICOMMON_BUSFLAG_MASTER;\n    \n    esp_err_t ret = spi_bus_initialize(SPI3_HOST, &bus_config, 2);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to initialize SPI bus: \" << esp_err_to_name(ret) << std::endl;\n        return;\n    }\n    \n    // Configure SD card device (SPI mode)\n    spi_device_interface_config_t sd_config = {};\n    sd_config.mode = 0;  // SPI mode 0\n    sd_config.clock_speed_hz = 400000;  // Start with 400kHz for initialization\n    sd_config.spics_io_num = m5tab5_pins::SPI3_CS_SD;\n    sd_config.queue_size = 5;\n    sd_config.command_bits = 0;\n    sd_config.address_bits = 0;\n    sd_config.dummy_bits = 0;\n    sd_config.flags = SPI_DEVICE_HALFDUPLEX;  // SD card is half-duplex\n    \n    spi_device_handle_t sd_handle;\n    ret = spi_bus_add_device(SPI3_HOST, &sd_config, &sd_handle);\n    if (ret != ESP_OK) {\n        std::cerr << \"Failed to add SD card device: \" << esp_err_to_name(ret) << std::endl;\n        spi_bus_free(SPI3_HOST);\n        return;\n    }\n    std::cout << \"SD card device added to SPI3 bus\\n\";\n    \n    // SD card initialization sequence\n    std::cout << \"Sending SD card initialization commands...\\n\";\n    \n    // CMD0: GO_IDLE_STATE\n    spi_transaction_t cmd0 = {};\n    cmd0.flags = SPI_TRANS_USE_TXDATA;\n    cmd0.length = 48;  // SD command is 6 bytes\n    cmd0.tx_data[0] = 0x40;  // CMD0\n    cmd0.tx_data[1] = 0x00;  // Argument\n    cmd0.tx_data[2] = 0x00;\n    cmd0.tx_data[3] = 0x00;\n    cmd0.tx_data[4] = 0x00;\n    cmd0.tx_data[5] = 0x95;  // CRC\n    \n    ret = spi_device_transmit(sd_handle, &cmd0);\n    if (ret == ESP_OK) {\n        std::cout << \"  CMD0 (GO_IDLE_STATE) sent successfully\\n\";\n    } else {\n        std::cout << \"  CMD0 failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // CMD8: SEND_IF_COND\n    spi_transaction_t cmd8 = {};\n    cmd8.flags = SPI_TRANS_USE_TXDATA | SPI_TRANS_USE_RXDATA;\n    cmd8.length = 48;  // 6 bytes command\n    cmd8.rxlength = 40;  // 5 bytes response\n    cmd8.tx_data[0] = 0x48;  // CMD8\n    cmd8.tx_data[1] = 0x00;  // Argument: VHS=1, check pattern=0xAA\n    cmd8.tx_data[2] = 0x00;\n    cmd8.tx_data[3] = 0x01;\n    cmd8.tx_data[4] = 0xAA;\n    cmd8.tx_data[5] = 0x87;  // CRC\n    \n    ret = spi_device_transmit(sd_handle, &cmd8);\n    if (ret == ESP_OK) {\n        std::cout << \"  CMD8 (SEND_IF_COND) sent successfully\\n\";\n        std::cout << \"  Response: \";\n        for (int i = 0; i < 4; i++) {\n            std::cout << std::hex << (int)cmd8.rx_data[i] << \" \";\n        }\n        std::cout << \"\\n\";\n    } else {\n        std::cout << \"  CMD8 failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Simulate block read (CMD17)\n    std::cout << \"Reading SD card block 0...\\n\";\n    uint8_t block_data[512];  // One block\n    \n    spi_transaction_t cmd17 = {};\n    cmd17.flags = SPI_TRANS_USE_TXDATA;\n    cmd17.length = 48;  // 6 bytes command\n    cmd17.tx_data[0] = 0x51;  // CMD17\n    cmd17.tx_data[1] = 0x00;  // Block address 0\n    cmd17.tx_data[2] = 0x00;\n    cmd17.tx_data[3] = 0x00;\n    cmd17.tx_data[4] = 0x00;\n    cmd17.tx_data[5] = 0xFF;  // Dummy CRC\n    \n    ret = spi_device_transmit(sd_handle, &cmd17);\n    if (ret == ESP_OK) {\n        std::cout << \"  CMD17 (READ_SINGLE_BLOCK) sent successfully\\n\";\n        \n        // Read block data (normally would wait for data token first)\n        spi_transaction_t read_block = {};\n        read_block.length = 512 * 8;  // 512 bytes\n        read_block.rx_buffer = block_data;\n        \n        ret = spi_device_transmit(sd_handle, &read_block);\n        if (ret == ESP_OK) {\n            std::cout << \"  Block data read successfully (512 bytes)\\n\";\n            std::cout << \"  First 16 bytes: \";\n            for (int i = 0; i < 16; i++) {\n                std::cout << std::hex << (int)block_data[i] << \" \";\n            }\n            std::cout << \"\\n\";\n        } else {\n            std::cout << \"  Block read failed: \" << esp_err_to_name(ret) << \"\\n\";\n        }\n    } else {\n        std::cout << \"  CMD17 failed: \" << esp_err_to_name(ret) << \"\\n\";\n    }\n    \n    // Cleanup\n    spi_bus_remove_device(sd_handle);\n    spi_bus_free(SPI3_HOST);\n    std::cout << \"SD card demo completed\\n\";\n}\n\n/**\n * @brief Demonstrate SPI frequency and timing calculations\n */\nvoid demo_spi_timing() {\n    std::cout << \"\\n=== SPI Timing and Frequency Demo ===\\n\";\n    \n    const int apb_freq = 80000000;  // 80 MHz APB clock\n    \n    // Test different target frequencies\n    std::vector<int> target_frequencies = {100000, 1000000, 10000000, 25000000, 40000000};\n    \n    std::cout << \"Frequency calculations for different targets:\\n\";\n    for (int target_freq : target_frequencies) {\n        int actual_freq = spi_get_actual_clock(apb_freq, target_freq, 128);\n        double accuracy = (double)actual_freq / target_freq * 100.0;\n        \n        std::cout << \"  Target: \" << target_freq / 1000 << \" kHz, \";\n        std::cout << \"Actual: \" << actual_freq / 1000 << \" kHz \";\n        std::cout << \"(\" << std::fixed << std::setprecision(1) << accuracy << \"%)\\n\";\n    }\n    \n    // Test timing calculations\n    std::cout << \"\\nTiming calculations:\\n\";\n    int dummy_bits, cycles_remain;\n    \n    esp_err_t ret = spi_get_timing(false, 0, 40000000, &dummy_bits, &cycles_remain);\n    if (ret == ESP_OK) {\n        std::cout << \"  40 MHz: dummy_bits=\" << dummy_bits \n                  << \", cycles_remain=\" << cycles_remain << \"\\n\";\n    }\n    \n    ret = spi_get_timing(true, 10, 10000000, &dummy_bits, &cycles_remain);\n    if (ret == ESP_OK) {\n        std::cout << \"  10 MHz (GPIO): dummy_bits=\" << dummy_bits \n                  << \", cycles_remain=\" << cycles_remain << \"\\n\";\n    }\n    \n    // Get frequency limits\n    int limit_iomux = spi_get_freq_limit(false, 0);\n    int limit_gpio = spi_get_freq_limit(true, 10);\n    \n    std::cout << \"\\nFrequency limits:\\n\";\n    std::cout << \"  IOMUX pins: \" << limit_iomux / 1000000 << \" MHz\\n\";\n    std::cout << \"  GPIO matrix: \" << limit_gpio / 1000000 << \" MHz\\n\";\n}\n\nint main() {\n    std::cout << \"M5Stack Tab5 ESP-IDF SPI API Demonstration\\n\";\n    std::cout << \"==========================================\\n\";\n    \n    try {\n        // Create and initialize emulator\n        auto config_result = m5tab5::emulator::config::Configuration::load_default();\n        if (!config_result.has_value()) {\n            std::cerr << \"Failed to load emulator configuration\" << std::endl;\n            return 1;\n        }\n        \n        auto emulator_result = m5tab5::emulator::EmulatorCore::create(config_result.value());\n        if (!emulator_result.has_value()) {\n            std::cerr << \"Failed to create emulator core\" << std::endl;\n            return 1;\n        }\n        \n        auto emulator = std::move(emulator_result.value());\n        auto init_result = emulator->initialize();\n        if (!init_result.has_value()) {\n            std::cerr << \"Failed to initialize emulator\" << std::endl;\n            return 1;\n        }\n        \n        // Initialize ESP-IDF layer\n        esp_err_t esp_result = esp_idf_init_all_with_core(emulator.get());\n        if (esp_result != ESP_OK) {\n            std::cerr << \"Failed to initialize ESP-IDF layer: \" \n                      << esp_err_to_name(esp_result) << std::endl;\n            return 1;\n        }\n        \n        std::cout << \"Emulator initialized successfully\\n\";\n        std::cout << \"ESP-IDF emulation version: \" << esp_idf_get_emulation_version() << \"\\n\\n\";\n        \n        // Run SPI demonstrations\n        demo_display_controller();\n        demo_touch_controller();\n        demo_sd_card();\n        demo_spi_timing();\n        \n        std::cout << \"\\n=== Demo Summary ===\\n\";\n        std::cout << \"✓ Display controller SPI communication demonstrated\\n\";\n        std::cout << \"✓ Touch panel SPI communication demonstrated\\n\";\n        std::cout << \"✓ SD card SPI communication demonstrated\\n\";\n        std::cout << \"✓ SPI timing and frequency calculations demonstrated\\n\";\n        std::cout << \"\\nAll M5Stack Tab5 SPI features working correctly!\\n\";\n        \n        // Cleanup\n        esp_idf_deinit_all();\n        emulator->shutdown();\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Exception occurred: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}