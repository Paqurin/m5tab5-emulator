#include "emulator/esp_idf/esp_partition.h"
#include "emulator/esp_idf/esp_idf_integration.h"
#include "emulator/storage/flash_controller.hpp"
#include "emulator/storage/partition_table.hpp"
#include "emulator/core/emulator_core.hpp"
#include "emulator/utils/logging.hpp"

#include <memory>
#include <vector>
#include <cstring>

using namespace m5tab5::emulator;
using namespace m5tab5::emulator::storage;

// Internal partition iterator structure
struct esp_partition_iterator_opaque_ {
    std::vector<esp_partition_t> partitions;
    size_t current_index;
    
    esp_partition_iterator_opaque_() : current_index(0) {}
};

// Static partition storage for persistent partition objects
static std::vector<std::unique_ptr<esp_partition_t>> partition_registry;

// Helper function to get flash controller
static FlashController* get_flash_controller() {
    auto* core = esp_idf_get_emulator_core();
    if (!core) {
        LOG_ERROR("EmulatorCore not available for partition operations");
        return nullptr;
    }
    
    auto flash_controller = core->getComponent<FlashController>();
    if (!flash_controller.has_value()) {
        LOG_ERROR("FlashController not available in emulator core");
        return nullptr;
    }
    
    return flash_controller.value();
}

// Helper function to get partition table
static PartitionTable* get_partition_table() {
    auto* controller = get_flash_controller();
    if (!controller) {
        return nullptr;
    }
    
    return controller->get_partition_table();
}

// Helper function to convert partition types
static esp_partition_type_t convert_partition_type(PartitionTable::PartitionType type) {
    switch (type) {
        case PartitionTable::PartitionType::APP:
            return ESP_PARTITION_TYPE_APP;
        case PartitionTable::PartitionType::DATA:
            return ESP_PARTITION_TYPE_DATA;
        default:
            return static_cast<esp_partition_type_t>(static_cast<uint8_t>(type));
    }
}

static esp_partition_subtype_t convert_partition_subtype(PartitionTable::PartitionSubtype subtype) {
    return static_cast<esp_partition_subtype_t>(static_cast<uint8_t>(subtype));
}

static PartitionTable::PartitionType convert_esp_partition_type(esp_partition_type_t type) {
    switch (type) {
        case ESP_PARTITION_TYPE_APP:
            return PartitionTable::PartitionType::APP;
        case ESP_PARTITION_TYPE_DATA:
            return PartitionTable::PartitionType::DATA;
        default:
            return static_cast<PartitionTable::PartitionType>(static_cast<uint8_t>(type));
    }
}

static PartitionTable::PartitionSubtype convert_esp_partition_subtype(esp_partition_subtype_t subtype) {
    return static_cast<PartitionTable::PartitionSubtype>(static_cast<uint8_t>(subtype));
}

// Helper function to convert partition entry to ESP partition
static esp_partition_t convert_to_esp_partition(const PartitionTable::PartitionEntry& entry) {
    esp_partition_t partition = {};
    
    partition.type = convert_partition_type(entry.type);
    partition.subtype = convert_partition_subtype(entry.subtype);
    partition.address = entry.offset;
    partition.size = entry.size;
    partition.encrypted = entry.is_encrypted();
    partition.readonly = entry.is_readonly();
    
    // Copy label (ensure null termination)
    std::strncpy(partition.label, entry.label.c_str(), sizeof(partition.label) - 1);
    partition.label[sizeof(partition.label) - 1] = '\0';
    
    return partition;
}

// Helper function to convert emulator error to ESP error
static esp_err_t convert_error(ErrorCode error) {
    switch (error) {
        case ErrorCode::SUCCESS:
            return ESP_OK;
        case ErrorCode::INVALID_PARAMETER:
            return ESP_ERR_INVALID_ARG;
        case ErrorCode::NOT_INITIALIZED:
            return ESP_ERR_INVALID_STATE;
        case ErrorCode::ADDRESS_OUT_OF_BOUNDS:
        case ErrorCode::INVALID_ADDRESS:
            return ESP_ERR_INVALID_SIZE;
        case ErrorCode::WRITE_PROTECTED:
            return ESP_ERR_NOT_ALLOWED;
        case ErrorCode::DEVICE_BUSY:
            return ESP_ERR_TIMEOUT;
        case ErrorCode::NOT_FOUND:
            return ESP_ERR_NOT_FOUND;
        case ErrorCode::FILE_NOT_FOUND:
            return ESP_ERR_NOT_FOUND;
        case ErrorCode::CHECKSUM_MISMATCH:
            return ESP_ERR_INVALID_CRC;
        default:
            return ESP_FAIL;
    }
}

extern "C" {

esp_partition_iterator_t esp_partition_find(esp_partition_type_t type,
                                           esp_partition_subtype_t subtype,
                                           const char* label) {
    
    auto* partition_table = get_partition_table();
    if (!partition_table) {
        LOG_ERROR("Partition table not available");
        return nullptr;
    }
    
    auto iterator = std::make_unique<esp_partition_iterator_opaque_>();
    auto all_partitions = partition_table->get_all_partitions();
    
    LOG_DEBUG("Searching partitions: type={}, subtype={}, label={}", 
             static_cast<int>(type), static_cast<int>(subtype), 
             label ? label : "ANY");
    
    // Filter partitions based on criteria
    for (const auto& entry : all_partitions) {
        bool matches = true;
        
        // Check type filter
        if (type != ESP_PARTITION_TYPE_ANY) {
            if (convert_partition_type(entry.type) != type) {
                matches = false;
            }
        }
        
        // Check subtype filter
        if (matches && subtype != ESP_PARTITION_SUBTYPE_ANY) {
            if (convert_partition_subtype(entry.subtype) != subtype) {
                matches = false;
            }
        }
        
        // Check label filter
        if (matches && label != nullptr) {
            if (entry.label != label) {
                matches = false;
            }
        }
        
        if (matches) {
            iterator->partitions.push_back(convert_to_esp_partition(entry));
            LOG_DEBUG("Found matching partition: {} (type={}, subtype={})", 
                     entry.label, static_cast<int>(entry.type), static_cast<int>(entry.subtype));
        }
    }
    
    LOG_DEBUG("Found {} matching partitions", iterator->partitions.size());
    
    if (iterator->partitions.empty()) {
        return nullptr;
    }
    
    return iterator.release();
}

const esp_partition_t* esp_partition_find_first(esp_partition_type_t type,
                                               esp_partition_subtype_t subtype,
                                               const char* label) {
    
    auto iterator = esp_partition_find(type, subtype, label);
    if (!iterator) {
        return nullptr;
    }
    
    const esp_partition_t* partition = esp_partition_next(iterator);
    esp_partition_iterator_release(iterator);
    
    return partition;
}

const esp_partition_t* esp_partition_next(esp_partition_iterator_t iterator) {
    if (!iterator) {
        return nullptr;
    }
    
    if (iterator->current_index >= iterator->partitions.size()) {
        return nullptr;
    }
    
    return &iterator->partitions[iterator->current_index++];
}

void esp_partition_iterator_release(esp_partition_iterator_t iterator) {
    if (iterator) {
        delete iterator;
    }
}

esp_err_t esp_partition_verify(const esp_partition_t* partition) {
    if (!partition) {
        return ESP_ERR_INVALID_ARG;
    }
    
    auto* partition_table = get_partition_table();
    if (!partition_table) {
        return ESP_ERR_INVALID_STATE;
    }
    
    // Find matching partition in table
    auto result = partition_table->get_partition(partition->label);
    if (!result.has_value()) {
        return ESP_ERR_NOT_FOUND;
    }
    
    const auto& entry = result.value();
    
    // Verify partition properties match
    if (entry.offset != partition->address ||
        entry.size != partition->size ||
        convert_partition_type(entry.type) != partition->type ||
        convert_partition_subtype(entry.subtype) != partition->subtype) {
        return ESP_ERR_INVALID_CRC;
    }
    
    return ESP_OK;
}

esp_err_t esp_partition_read(const esp_partition_t* partition,
                            size_t src_offset,
                            void* dst,
                            size_t size) {
    
    if (!partition || !dst || size == 0) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (src_offset + size > partition->size) {
        return ESP_ERR_INVALID_SIZE;
    }
    
    auto* controller = get_flash_controller();
    if (!controller) {
        return ESP_ERR_INVALID_STATE;
    }
    
    LOG_DEBUG("Partition read: {} offset={} size={}", partition->label, src_offset, size);
    
    uint32_t flash_addr = FlashController::FLASH_BASE_ADDRESS + partition->address + src_offset;
    auto result = controller->read(flash_addr, dst, size);
    
    return result.has_value() ? ESP_OK : convert_error(result.error());
}

esp_err_t esp_partition_write(const esp_partition_t* partition,
                             size_t dst_offset,
                             const void* src,
                             size_t size) {
    
    if (!partition || !src || size == 0) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (partition->readonly) {
        return ESP_ERR_NOT_ALLOWED;
    }
    
    if (dst_offset + size > partition->size) {
        return ESP_ERR_INVALID_SIZE;
    }
    
    auto* controller = get_flash_controller();
    if (!controller) {
        return ESP_ERR_INVALID_STATE;
    }
    
    LOG_DEBUG("Partition write: {} offset={} size={}", partition->label, dst_offset, size);
    
    // Enable write first
    auto write_enable_result = controller->write_enable();
    if (!write_enable_result.has_value()) {
        return convert_error(write_enable_result.error());
    }
    
    uint32_t flash_addr = FlashController::FLASH_BASE_ADDRESS + partition->address + dst_offset;
    auto result = controller->write(flash_addr, src, size);
    
    return result.has_value() ? ESP_OK : convert_error(result.error());
}

esp_err_t esp_partition_erase_range(const esp_partition_t* partition,
                                   size_t offset,
                                   size_t size) {
    
    if (!partition || size == 0) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (partition->readonly) {
        return ESP_ERR_NOT_ALLOWED;
    }
    
    if (offset + size > partition->size) {
        return ESP_ERR_INVALID_SIZE;
    }
    
    auto* controller = get_flash_controller();
    if (!controller) {
        return ESP_ERR_INVALID_STATE;
    }
    
    LOG_DEBUG("Partition erase: {} offset={} size={}", partition->label, offset, size);
    
    // Enable write first
    auto write_enable_result = controller->write_enable();
    if (!write_enable_result.has_value()) {
        return convert_error(write_enable_result.error());
    }
    
    uint32_t flash_addr = FlashController::FLASH_BASE_ADDRESS + partition->address + offset;
    auto result = controller->erase_range(flash_addr, size);
    
    return result.has_value() ? ESP_OK : convert_error(result.error());
}

esp_err_t esp_partition_mmap(const esp_partition_t* partition,
                            size_t offset,
                            size_t size,
                            esp_flash_read_mode_t memory_map_mode,
                            const void** out_ptr,
                            esp_partition_mmap_handle_t* out_handle) {
    
    if (!partition || !out_ptr || !out_handle || size == 0) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (offset + size > partition->size) {
        return ESP_ERR_INVALID_SIZE;
    }
    
    auto* controller = get_flash_controller();
    if (!controller) {
        return ESP_ERR_INVALID_STATE;
    }
    
    LOG_DEBUG("Partition mmap: {} offset={} size={}", partition->label, offset, size);
    
    // For emulation, we'll read the data into a buffer and return pointer to it
    // In a real implementation, this would set up memory mapping
    
    uint32_t flash_addr = FlashController::FLASH_BASE_ADDRESS + partition->address + offset;
    
    // Allocate buffer for mapped data
    auto buffer = std::make_unique<uint8_t[]>(size);
    auto result = controller->read(flash_addr, buffer.get(), size);
    
    if (!result.has_value()) {
        return convert_error(result.error());
    }
    
    // Store buffer in registry and return handle
    static uint32_t next_handle = 1;
    uint32_t handle = next_handle++;
    
    *out_ptr = buffer.get();
    *out_handle = handle;
    
    // Store buffer for later cleanup (simplified approach for emulation)
    // In production, this would use proper memory mapping
    
    return ESP_OK;
}

void esp_partition_munmap(esp_partition_mmap_handle_t handle) {
    LOG_DEBUG("Partition munmap: handle={}", handle);
    
    // For emulation, we would clean up the buffer here
    // In production, this would unmap the memory region
}

esp_err_t esp_partition_get_sha256(const esp_partition_t* partition, uint8_t* sha_256) {
    if (!partition || !sha_256) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // For emulation, generate a pseudo-SHA256 based on partition properties
    // In production, this would calculate actual SHA256 of partition contents
    
    memset(sha_256, 0, 32);
    
    // Use partition address and size to generate pseudo-hash
    uint32_t hash_input = partition->address ^ partition->size;
    for (int i = 0; i < 8; i++) {
        *(uint32_t*)(sha_256 + i * 4) = hash_input + i;
    }
    
    LOG_DEBUG("Generated SHA256 for partition: {}", partition->label);
    return ESP_OK;
}

bool esp_partition_check_identity(const esp_partition_t* partition) {
    if (!partition) {
        return false;
    }
    
    // For emulation, assume all partitions are valid
    return true;
}

const esp_partition_t* esp_partition_register_external(const esp_partition_t* partition_info) {
    if (!partition_info) {
        return nullptr;
    }
    
    // Create persistent copy of partition
    auto partition_copy = std::make_unique<esp_partition_t>(*partition_info);
    const esp_partition_t* result = partition_copy.get();
    
    partition_registry.push_back(std::move(partition_copy));
    
    LOG_DEBUG("Registered external partition: {}", partition_info->label);
    return result;
}

esp_err_t esp_partition_deregister_external(const esp_partition_t* partition) {
    if (!partition) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Find and remove partition from registry
    auto it = std::find_if(partition_registry.begin(), partition_registry.end(),
                          [partition](const std::unique_ptr<esp_partition_t>& p) {
                              return p.get() == partition;
                          });
    
    if (it != partition_registry.end()) {
        LOG_DEBUG("Deregistered external partition: {}", partition->label);
        partition_registry.erase(it);
        return ESP_OK;
    }
    
    return ESP_ERR_NOT_FOUND;
}

} // extern "C"